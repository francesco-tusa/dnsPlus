package naming;

/**
 * This program is free software: you can redistribute it and/or modify it 
 * under the terms of the GNU General Public License as published by the Free 
 * Software Foundation, either version 3 of the License, or (at your option) 
 * any later version. 
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT 
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
 * more details. 
 * 
 * You should have received a copy of the GNU General Public License along with 
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 */

import java.math.*;
import java.util.*;

/**
 * Paillier Cryptosystem <br><br>
 * References: <br>
 * [1] Pascal Paillier, "Public-Key Cryptosystems Based on Composite Degree Residuosity Classes," EUROCRYPT'99.
 *    URL: <a href="http://www.gemplus.com/smart/rd/publications/pdf/Pai99pai.pdf">http://www.gemplus.com/smart/rd/publications/pdf/Pai99pai.pdf</a><br>
 * 
 * [2] Paillier cryptosystem from Wikipedia. 
 *    URL: <a href="http://en.wikipedia.org/wiki/Paillier_cryptosystem">http://en.wikipedia.org/wiki/Paillier_cryptosystem</a>
 * @author Kun Liu (kunliu1@cs.umbc.edu)
 * @version 1.0
 */
public class Paillier {

    /**
     * p and q are two large primes. 
     * lambda = lcm(p-1, q-1) = (p-1)*(q-1)/gcd(p-1, q-1).
     */
    private BigInteger p,  q,  lambda, mu;
    /**
     * n = p*q, where p and q are two large primes.
     */
    public BigInteger n;
    /**
     * nsquare = n*n
     */
    public BigInteger nsquare;
    /**
     * a random integer in Z*_{n^2} where gcd (L(g^lambda mod n^2), n) = 1.
     */
    private BigInteger g;
    /**
     * number of bits of modulus
     */
    private int bitLength;
    
    // this will be randomly generated for each context (SPEnc)
    private BigInteger r, t;
    
    // randonly generated by a publisher for each publication
    //private BigInteger rv;
    
    private final int l = 128; // this is the number of bits used to represent each portion of the address
    private int s;
    private int u;
    
    

    /**
     * Constructs an instance of the Paillier cryptosystem.
     * @param bitLengthVal number of bits of modulus
     * @param certainty The probability that the new BigInteger represents a prime number will exceed (1 - 2^(-certainty)). The execution time of this constructor is proportional to the value of this parameter.
     */
    public Paillier(int bitLengthVal, int certainty) {
        KeyGeneration(bitLengthVal, certainty);
    }

    /**
     * Constructs an instance of the Paillier cryptosystem with 512 bits of modulus and at least 1-2^(-64) certainty of primes generation.
     */
    public Paillier() {
        KeyGeneration(512, 64);
    }

    /**
     * Sets up the public key and private key.
     * @param bitLengthVal number of bits of modulus.
     * @param certainty The probability that the new BigInteger represents a prime number will exceed (1 - 2^(-certainty)). The execution time of this constructor is proportional to the value of this parameter.
     */
    public void KeyGeneration(int bitLengthVal, int certainty) {
        bitLength = bitLengthVal;
        /*Constructs two randomly generated positive BigIntegers that are probably prime, with the specified bitLength and certainty.*/
        p = new BigInteger(bitLength / 2, certainty, new Random());
        q = new BigInteger(bitLength / 2, certainty, new Random());

        n = p.multiply(q);
        nsquare = n.multiply(n);

        //g = new BigInteger("2");
        g = BigInteger.valueOf(2);
        
        lambda = p.subtract(BigInteger.ONE).multiply(q.subtract(BigInteger.ONE)).divide(
                p.subtract(BigInteger.ONE).gcd(q.subtract(BigInteger.ONE)));
        /* check whether g is good.*/
        if (g.modPow(lambda, nsquare).subtract(BigInteger.ONE).divide(n).gcd(n).intValue() != 1) {
            System.out.println("g is not good. Choose g again.");
            System.exit(1);
        }
        
       
        
        mu = g.modPow(lambda, nsquare).subtract(BigInteger.ONE).divide(n).modInverse(n);
        
        System.out.println("n: " + n);
        System.out.println("bitlength: " + bitLength);
        
        s = bitLength;
        u = ((s-1) - l)/2;
        
        System.out.println("s: " + s);
        System.out.println("u: " + u);
        System.out.println("l: " + l);
        r = new BigInteger(u-l, new Random());
        t = new BigInteger(u-l, new Random());
        
//        
//        System.out.println(r.bitCount());
//        System.out.println(t.bitCount());
        
    }

    /**
     * Encrypts plaintext m. ciphertext c = g^m * r^n mod n^2. This function explicitly requires random input r to help with encryption.
     * @param m plaintext as a BigInteger
     * @param r random plaintext to help with encryption
     * @return ciphertext as a BigInteger
     */
    public BigInteger Encryption(BigInteger m, BigInteger rand) {
        return g.modPow(m, nsquare).multiply(rand.modPow(n, nsquare)).mod(nsquare);
    }

    /**
     * Encrypts plaintext m. ciphertext c = g^m * r^n mod n^2. This function automatically generates random input r (to help with encryption).
     * @param m plaintext as a BigInteger
     * @return ciphertext as a BigInteger
     */
    public BigInteger Encryption(BigInteger m) {
        return g.modPow(m, nsquare).multiply(r.modPow(n, nsquare)).mod(nsquare);

    }

    /**
     * Decrypts ciphertext c. plaintext m = L(c^lambda mod n^2) * u mod n, where u = (L(g^lambda mod n^2))^(-1) mod n.
     * @param c ciphertext as a BigInteger
     * @return plaintext as a BigInteger
     */
    public BigInteger Decryption(BigInteger c) {
        return c.modPow(lambda, nsquare).subtract(BigInteger.ONE).divide(n).multiply(mu).mod(n);
    }
    
    // similar to digital signature: only those who know the private parameter lambda can encrypt
    // lambda and square are given by the SPENC to pubs and subs
    public BigInteger ShiftedEncryption(BigInteger m) {
        //return g.modPow(m.multiply(lambda), nsquare).multiply(r.modPow(n.multiply(lambda), nsquare)).mod(nsquare);
        BigInteger rand = (new BigInteger(bitLength, new Random()));//.mod(n.subtract(BigInteger.ONE));
        return Encryption(m, rand).modPow(lambda, nsquare);

    }
    
    // similar to digital signature: using n and u as the public key decryption can be performed
    // Broker do not know lambda
    public BigInteger ShiftedDecryption(BigInteger c) {
        //return ((c.modPow(BigInteger.valueOf(1), nsquare).subtract(BigInteger.ONE)).divide(n)).multiply(u).mod(n);
        return (c.mod(nsquare).subtract(BigInteger.ONE)).divide(n).multiply(mu).mod(n);
    }
    
    // publishers introduce the term g.modPow(t, nsquare) to blind values 
    //rv is a random number generated by the publisher    
    public BigInteger pubBlind(BigInteger m) {
        BigInteger rv = (new BigInteger(s-1-u, new Random())).mod(r);
        //BigInteger rv = (new BigInteger(s-1-uu-1, new Random())).mod(r.divide(BigInteger.TWO));
        
        return g.modPow(t, nsquare)
                .multiply(ShiftedEncryption(r).modPow(r, nsquare))
                .multiply(ShiftedEncryption(r.multiply(m.subtract(BigInteger.valueOf(1)))))
                .multiply(ShiftedEncryption(rv));
    }
    
    // subscribers introduce the term g.modPow(t.multiply(BigInteger.valueOf(-1)), nsquare) to blind values
    public BigInteger subBlind(BigInteger m) {
        BigInteger rv = (new BigInteger(s-1-u, new Random())).mod(r);
        //BigInteger rv = (new BigInteger(s-1-uu-1, new Random())).mod(r.divide(BigInteger.TWO));
        
        
        return g.modPow(t.multiply(BigInteger.valueOf(-1)), nsquare)
                .multiply(ShiftedEncryption(r.multiply(BigInteger.valueOf(-1))).modPow(r, nsquare))
                .multiply(ShiftedEncryption(r.multiply((BigInteger.valueOf(1).subtract(m)))))
                //.multiply(ShiftedEncryption(rv))
                ;
    }
    
    // computes the same result as pubBlind but uses the parameters distributed by the SPEnc
    public BigInteger actualPubBlind(BigInteger m) {
        BigInteger rv = (new BigInteger(s-1-u, new Random())).mod(r);
        //BigInteger rv = (new BigInteger(s-1-uu-1, new Random())).mod(r.divide(BigInteger.TWO));
        
        // known parameters from SPEnc
        BigInteger param1 = ShiftedEncryption(r);
        BigInteger param2 = ShiftedEncryption(BigInteger.valueOf(1));
        BigInteger param3 = g.modPow(t, nsquare).multiply(ShiftedEncryption(r));
        
        return param3.multiply(param1.modPow(m.subtract(BigInteger.valueOf(1)), nsquare))
                     .multiply(param2.modPow(rv, nsquare));
                     //.multiply(ShiftedEncryption(rv));
    }
    

     // computes the same result as subBlind but uses the parameters distributed by the SPEnc
    public BigInteger actualSubBlind(BigInteger m) {
        //BigInteger rv = (new BigInteger(s-1-uu, new Random())).mod(r);
        //BigInteger rv = (new BigInteger(s-1-uu-1, new Random())).mod(r.divide(BigInteger.TWO));
        
        // known parameters from SPEnc
        BigInteger param1 = ShiftedEncryption(r.multiply(BigInteger.valueOf(-1)));
        //BigInteger param2 = ShiftedEncryption(BigInteger.valueOf(-1));
        BigInteger param3 = g.modPow(t.multiply(BigInteger.valueOf(-1)), nsquare)
                             .multiply(ShiftedEncryption(r.multiply(BigInteger.valueOf(-1))));
        
        return param3.multiply(param1.modPow(m.subtract(BigInteger.valueOf(1)), nsquare))
                     ;//.multiply(ShiftedEncryption(rv));
    }
    
    
    public BigInteger actualSubBlindCover(BigInteger m) {
        BigInteger rv = (new BigInteger(s-1-u, new Random())).mod(r);
        
        // known parameters from SPEnc
        BigInteger param1 = ShiftedEncryption(r.multiply(BigInteger.valueOf(-1)));
        BigInteger param2 = ShiftedEncryption(BigInteger.valueOf(-1));
        //BigInteger param3 = g.modPow(t.multiply(BigInteger.valueOf(-1)), nsquare)
        //                     .multiply(ShiftedEncryption(r.multiply(BigInteger.valueOf(-1))));
        
        BigInteger param4 = g.modPow(t, nsquare).multiply(ShiftedEncryption(r));
        
        return param4.multiply(param1.modPow(BigInteger.valueOf(1).subtract(m), nsquare))
                     .multiply(param2.modPow(rv.multiply(BigInteger.valueOf(-1)), nsquare));
    }
    

    // If d > n/2 then vPub < x1Sub. 
    // To have a == match one needs to check that both vPub(x+1) < x1Sub is TRUE AND vPub (x-1) > x1Sub is TRUE
    // There needs to be two checks with two different valus x+1 and x-1. These need to be conveyed in the UPDATE message
    // n is the number of bits to the encoding
    public Boolean brokerMatch(BigInteger vPub, BigInteger x1Sub) {
        BigInteger d = ShiftedDecryption(vPub.multiply(x1Sub));
        
        int result = d.compareTo(n.divide(BigInteger.valueOf(2)));
        
        if (!d.equals(0) && result < 0) {
            System.out.println("Publication Value (v) >= Subscription Value (x)");
            return true;
        }
        else {
            System.out.println("Publication Value (v) < Subscription Value (x)");
            return false;
        }
        
        //System.out.println("Raw Difference: " + d);
        //System.out.println("Difference: " + d.subtract(rv).divide(r));
        //return d;
    }
    // Later on, we will have loop on the database and do 2 brokerMatch checks per entry (we are only dealing with equality checks for now)

    
    public Boolean brokerEqualityMatch(BigInteger vPub, BigInteger x1Sub, BigInteger x1SubPlusOne) {
     
        
        BigInteger d1 = ShiftedDecryption(vPub.multiply(x1Sub));
        
        int result1 = d1.compareTo(n.divide(BigInteger.valueOf(2)));
        
        BigInteger d2 = ShiftedDecryption(vPub.multiply(x1SubPlusOne));
        
        int result2 = d2.compareTo(n.divide(BigInteger.valueOf(2)));
        
        
       
        //System.out.println("r1: " + result1 + " r2: " + result2);
        
        if ( (!d1.equals(0) && result1 < 0) && (!d2.equals(0) && result2 > 0))
        {
            System.out.println("Publication Value (v) equals to Subscription Value (x)");
            return true;
        }
        else {
            System.out.println("Publication Value is different from Subscription Value (x)");
            return false;
        }
        
        //System.out.println("Raw Difference: " + d);
        //System.out.println("Difference: " + d.subtract(rv).divide(r));
        //return d;
    }
    
    
    
    // x2Sub1 is the equivalent of bval_c2(E(v1)) and x1Sub2 is the equivalent of bval_c1(E(-v2)) in the paper
    // in the slides x2Sub1 is x1'' and x1Sub2 is x2' 
    public Boolean brokerCover(BigInteger x2Sub1, BigInteger x1Sub2) {
        BigInteger d = ShiftedDecryption(x2Sub1.multiply(x1Sub2));
        
        int result = d.compareTo(n.divide(BigInteger.valueOf(2)));
        
        if (!d.equals(0) && result < 0) {
            System.out.println("Value of Subscription 1 (x1) >= Value of Subscription 2 (x2)");
            return true;
        }
        else {
            System.out.println("Value of Subscription 1 (x1) < Value of Subscription 2 (x2)");
            return false;
        }
    }
    
    
    
    private String generateString(int length) 
    {
        int leftLimit = 97; // letter 'a'
        int rightLimit = 122; // letter 'z'
        int targetStringLength = length;
        Random random = new Random();
        StringBuilder buffer = new StringBuilder(targetStringLength);
        for (int i = 0; i < targetStringLength; i++) {
            int randomLimitedInt = leftLimit + (int)(random.nextFloat() * (rightLimit - leftLimit + 1));
            buffer.append((char) randomLimitedInt);
        }
        
        return buffer.toString();
    }
    
    
    private BigInteger generateBigInteger(int bitCount) {
        Random r = new Random();
        return new BigInteger(bitCount, r);
    }
    
    
    public void runTest(int bitCount, int iterations)
    {
        double pub = 0, sub = 0, match = 0;
        long avgBitCount = 0;
        
        for (int i = 0; i < iterations; i++)
        {
            BigInteger m = generateBigInteger(bitCount);
            avgBitCount += m.bitCount();
            
            long t1 = System.nanoTime();
            BigInteger v = actualPubBlind(m);
            pub += System.nanoTime() - t1;
            
            long t2 = System.nanoTime();
            BigInteger x = actualSubBlind(m);
            sub += System.nanoTime()- t2;
            
            long t3 = System.nanoTime();
            brokerMatch(v, x);
            match += System.nanoTime() - t3;
            
        }
        
        System.out.println();
        System.out.println("Key size: " + bitLength + " max bit count: " + bitCount);
        System.out.println("Average bit count: " + avgBitCount / iterations);
        System.out.println("Publication blind (ms): " + (pub / 1000000) / iterations);
        System.out.println("Subscription blind (ms): " + (sub / 1000000) / iterations);
        System.out.println("Match (ms): " + (match / 1000000) / iterations);
        System.out.println();
        
    }
    
    
    /**
     * main function
     * @param str input string
     */
    public static void main(String[] str) {
        int iterations = 1000;
        int[] keys = {512, 1024, 2048};
        int[] bitCounts = {8, 16, 32};
        
//        Paillier paillier;
        
//        for (int key : keys)
//            for (int bitCount : bitCounts) 
//            {
//                if (bitCount >= key) break;
//                
//                paillier = new Paillier(key, key/8);
//                paillier.runTest(bitCount, iterations);
//            }
                
        
        
        /* instantiating an object of Paillier cryptosystem*/
        Paillier paillier = new Paillier(2048, 2048/8);
        //Paillier paillier = new Paillier();
        
        /* instantiating two plaintext msgs*/
        
        byte[] service1Bytes = "www.google.com".toLowerCase().getBytes();
        byte[] service2Bytes = "www.google.col".toLowerCase().getBytes();
        byte[] service3Bytes = "www.google.con".toLowerCase().getBytes();
        
        
        for (int i=0; i < service1Bytes.length; i++) {
            System.out.print(service1Bytes[i] + " ");
        }
        
        System.out.println();
        
        for (int i=0; i < service2Bytes.length; i++) {
            System.out.print(service2Bytes[i] + " ");
        }        
        
        System.out.println();
        
        for (int i=0; i < service3Bytes.length; i++) {
            System.out.print(service3Bytes[i] + " ");
        }
        
        System.out.println();
        
        System.out.println(service1Bytes.length * 8);
        System.out.println(service2Bytes.length * 8);
        System.out.println(service3Bytes.length * 8);
        
        
        BigInteger service1 = new BigInteger(service1Bytes);
        BigInteger service2 = new BigInteger(service2Bytes);
        BigInteger service3 = new BigInteger(service3Bytes);
       
        
        System.out.println(service1.bitCount());
        System.out.println(service2.bitCount());
        System.out.println(service3.bitCount());
        
        System.out.println("");
        
        BigInteger ShiftedEncryption = paillier.ShiftedEncryption(service2);
        BigInteger ShiftedDecryption = paillier.ShiftedDecryption(ShiftedEncryption);
        
        byte[] array = ShiftedDecryption.toByteArray();
        
        for (int i=0; i < array.length; i++) {
            System.out.print(array[i] + " ");
        }
        
        
        System.out.println("");
        
        for (int i=0; i < 5; i++) {
            BigInteger sub1 = paillier.subBlind(service1);
            System.out.println(sub1);
            BigInteger pub1 = paillier.pubBlind(service3);
            System.out.println(pub1);
            paillier.brokerMatch(pub1, sub1);
            
        }
        
        
        for (int i=0; i < 5; i++) {
        
            BigInteger sub1 = paillier.actualSubBlind(service1);
            //BigInteger sub1MinusOne = paillier.actualSubBlind(service1.subtract(BigInteger.ONE));
            BigInteger sub1PlusOne = paillier.actualSubBlind(service1.add(BigInteger.ONE));
            System.out.println(sub1);
            //System.out.println(sub1.bitCount());
            
            BigInteger pub1 = paillier.actualPubBlind(service1);
            System.out.println(pub1);
        
            BigInteger pub2 = paillier.actualPubBlind(service2);
            System.out.println(pub2);
            
            BigInteger pub3 = paillier.actualPubBlind(service3);
            System.out.println(pub3);
            
            paillier.brokerMatch(pub1, sub1);
            paillier.brokerMatch(pub2, sub1);
            paillier.brokerMatch(pub3, sub1);
            
            paillier.brokerEqualityMatch(pub1, sub1, sub1PlusOne);
            paillier.brokerEqualityMatch(pub2, sub1, sub1PlusOne);
            paillier.brokerEqualityMatch(pub3, sub1, sub1PlusOne);
            
            System.out.println("");  
        }

    }
}